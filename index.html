<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R√©seau de Neurones Spatial (Guid√©)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: #f8fafc;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1700px;
            margin: 0 auto;
            background: #1e293b;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            border: 1px solid #334155;
            position: relative;
        }
        
        /* HEADER & HELP TOGGLE */
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
        }
        
        h1 {
            text-align: center;
            color: #38bdf8;
            margin: 0;
            flex-grow: 1;
        }

        .help-toggle-container {
            position: absolute;
            right: 0;
            top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(15, 23, 42, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid #475569;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #475569;
            transition: .4s;
            border-radius: 20px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #f59e0b; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* HELP BUBBLES */
        .help-bubble {
            position: absolute;
            background: #f59e0b;
            color: #1e1b4b;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
            z-index: 1000;
            max-width: 250px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            display: none; /* Hidden by default */
        }
        .help-bubble.visible {
            opacity: 1;
            transform: translateY(0);
            display: block;
            animation: bounce-gentle 2s infinite;
        }
        .help-bubble::after {
            content: '';
            position: absolute;
            border-width: 8px;
            border-style: solid;
        }
        /* Arrow types */
        .help-bubble.arrow-top::after {
            bottom: 100%; left: 50%; margin-left: -8px;
            border-color: transparent transparent #f59e0b transparent;
        }
        .help-bubble.arrow-bottom::after {
            top: 100%; left: 50%; margin-left: -8px;
            border-color: #f59e0b transparent transparent transparent;
        }

        @keyframes bounce-gentle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* --- EXISTING STYLES --- */
        .guide-steps {
            display: flex;
            justify-content: space-between;
            background: #0f172a;
            border: 2px solid #38bdf8;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            gap: 20px;
        }
        .step {
            flex: 1;
            text-align: left;
            padding: 10px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 10px;
            border-left: 4px solid #38bdf8;
        }
        .step h3 { margin: 0 0 10px 0; color: #7dd3fc; font-size: 1.1em; }
        .step p { margin: 0; font-size: 0.9em; color: #cbd5e1; line-height: 1.4; }
        .step-number { font-size: 1.5em; float: right; opacity: 0.2; font-weight: bold; }

        .symbol-item {
            background: #1e293b;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #38bdf8;
            color: #cbd5e1;
            font-size: 13px;
        }
        .symbol-item strong { color: #38bdf8; }

        .input-methods {
            display: flex;
            justify-content: center;
            align-items: stretch;
            gap: 20px;
            margin: 20px 0;
        }
        
        .method-card {
            background: rgba(15, 23, 42, 0.6);
            border: 2px solid #334155;
            border-radius: 15px;
            padding: 20px;
            max-width: 500px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        .method-card h3 { margin-top: 0; color: #e2e8f0; font-size: 1.1em; }
        
        .locked-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(4px);
            z-index: 10;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #94a3b8;
            transition: opacity 0.5s;
        }
        .lock-icon { font-size: 40px; margin-bottom: 10px; }
        
        #drawingCanvas {
            background: #f8fafc;
            border-radius: 10px;
            cursor: crosshair;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
            touch-action: none;
            border: 2px dashed #94a3b8;
            margin: 10px 0;
        }
        .draw-controls { margin-top: 10px; display: flex; gap: 10px; width: 100%; justify-content: center;}
        .btn-draw { padding: 10px 15px; font-size: 14px; font-weight: bold; color: white; border: none; border-radius: 8px; cursor: pointer; transition: transform 0.2s;}
        .btn-draw:hover { transform: scale(1.05); }

        .network-container {
            position: relative;
            background: #0f172a;
            border-radius: 20px;
            padding: 40px 20px;
            margin: 40px 0;
            border: 1px solid #334155;
            overflow: hidden;
        }

        #synapseCanvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none;
        }

        .network-layers {
            position: relative; z-index: 1; display: flex; justify-content: space-between; align-items: stretch; min-height: 550px;
        }

        .layer {
            display: flex; flex-direction: column; justify-content: space-around; align-items: center; width: 20%;
        }

        .layer-title {
            font-weight: bold; font-size: 1.1em; margin-bottom: 20px; color: #94a3b8; text-align: center; background: rgba(15, 23, 42, 0.8); padding: 5px 10px; border-radius: 10px; white-space: nowrap;
        }

        .node {
            background: #1e293b; border: 2px solid #475569; border-radius: 10px; padding: 6px; width: 140px; text-align: center; transition: all 0.3s ease; position: relative; margin: 3px 0; box-shadow: 0 4px 6px rgba(0,0,0,0.3); z-index: 2;
        }

        .node-input { border-color: #6366f1; width: 150px; }
        .node-hidden-1 { border-color: #8b5cf6; } 
        .node-hidden-2 { border-color: #d946ef; } 
        .node-output { border-color: #10b981; width: 110px; }

        .node.active { box-shadow: 0 0 20px currentColor; transform: scale(1.05); }
        .node.winner { background: #064e3b; border-color: #10b981; box-shadow: 0 0 30px rgba(16, 185, 129, 0.8); }

        .node-name { font-size: 12px; font-weight: bold; margin-bottom: 2px; color: #f8fafc; white-space: nowrap; }
        .node-specialty { font-size: 10px; color: #cbd5e1; margin-bottom: 2px; font-style: italic; height: 12px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }

        .gauge-container { background: #334155; height: 5px; border-radius: 3px; overflow: hidden; margin-top: 2px; }
        .gauge-fill { height: 100%; width: 0%; background: #10b981; transition: width 0.3s ease; }
        .node-val { font-size: 9px; color: #94a3b8; margin-top: 1px; }

        .controls {
            display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 15px; margin: 30px 0; background: #0f172a; padding: 20px; border-radius: 15px; border: 1px solid #334155; position: relative;
        }

        button, select {
            background: #38bdf8; color: #0f172a; border: none; padding: 12px 25px; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.2s;
        }
        select { background: #334155; color: white; border: 1px solid #475569; }
        button:hover:not(:disabled) { background: #0ea5e9; transform: translateY(-2px); }
        button:disabled { background: #475569; color: #94a3b8; cursor: not-allowed; }
        
        .btn-train { background: #8b5cf6; color: white; box-shadow: 0 0 15px rgba(139, 92, 246, 0.4); animation: pulse-btn 2s infinite; }
        @keyframes pulse-btn { 0% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(139, 92, 246, 0); } 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); } }
        .btn-train.success { animation: none; background: #10b981; box-shadow: none; cursor: default; }

        .training-status {
            display: none; background: #1e1b4b; border: 2px solid #8b5cf6; border-radius: 15px; padding: 25px; margin: 20px 0; text-align: center;
        }
        .epoch-bar-container { width: 100%; height: 20px; background: #312e81; border-radius: 10px; margin: 15px 0; overflow: hidden; }
        .epoch-bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #8b5cf6, #d946ef); transition: width 0.1s linear; }

        .result-box {
            text-align: center; font-size: 1.5em; padding: 20px; border-radius: 10px; margin-top: 20px; display: none; position: relative;
        }
        .result-box.success { background: rgba(16, 185, 129, 0.2); border: 2px solid #10b981; color: #34d399; }
        .result-box.error { background: rgba(239, 68, 68, 0.2); border: 2px solid #ef4444; color: #f87171; }
        
        .detected-features {
            font-size: 0.6em; color: #cbd5e1; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; text-align: left;
        }
        .dataset-info { font-size: 12px; color: #94a3b8; margin-top: 10px; font-style: italic; }

        .result-actions {
            margin-top: 15px; padding-top: 10px; border-top: 1px solid #475569; display: flex; flex-direction: column; gap: 10px; align-items: center;
        }
        .validation-area {
            background: rgba(16, 185, 129, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3); width: 100%;
        }
        .correction-area {
            background: rgba(239, 68, 68, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(239, 68, 68, 0.3); width: 100%;
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- HEADER AVEC BOUTON AIDE -->
        <div class="header-row">
            <h1>üß† R√©seau de Neurones Spatial</h1>
            <div class="help-toggle-container">
                <span style="font-size:14px; font-weight:bold; color:#f59e0b;">Mode Guide</span>
                <label class="switch">
                    <input type="checkbox" id="helpToggle" checked onchange="toggleHelp()">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <!-- BULLES D'AIDE (Positionn√©es dynamiquement) -->
        <div id="help-bubble-1" class="help-bubble arrow-bottom">
            üëã <strong>√âtape 1 :</strong><br>Le cerveau est vide ! Commencez par cliquer ici pour l'entra√Æner.
        </div>
        
        <div id="help-bubble-2" class="help-bubble arrow-bottom">
            ‚úçÔ∏è <strong>√âtape 2 :</strong><br>Super ! Maintenant, dessinez un chiffre (0-9) dans cette case.
        </div>

        <div id="help-bubble-3" class="help-bubble arrow-top">
            üöÄ <strong>√âtape 3 :</strong><br>Cliquez ici pour voir si l'IA devine votre chiffre !
        </div>

        <div id="help-bubble-4" class="help-bubble arrow-top">
            üë®‚Äçüè´ <strong>√âtape 4 (Cruciale) :</strong><br>
            ‚Ä¢ Si c'est vert : <strong>Validez</strong> pour renforcer.<br>
            ‚Ä¢ Si c'est rouge : <strong>Corrigez</strong> l'IA ! C'est le seul moyen pour qu'elle apprenne votre √©criture.
        </div>

        <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
            <div class="symbol-item"><strong>Zones</strong> : Haut, Milieu, Bas</div>
            <div class="symbol-item"><strong>H</strong> = Horizontal</div>
            <div class="symbol-item"><strong>B</strong> = Boucle</div>
            <div class="symbol-item"><strong>C</strong> = Courbe</div>
        </div>

        <div class="input-methods">
            <div class="method-card" style="position:relative;">
                <h3>‚úçÔ∏è Zone de Dessin Libre</h3>
                <div class="locked-overlay" id="drawingLock">
                    <div class="lock-icon">üîí</div>
                    <div><strong>Zone Verrouill√©e</strong></div>
                    <div style="font-size:0.8em; margin-top:5px;">Cliquez sur "Entra√Æner" ci-dessous</div>
                </div>
                <canvas id="drawingCanvas" width="200" height="200"></canvas>
                <div class="draw-controls" id="drawControlsContainer">
                    <button class="btn-draw" onclick="clearDrawing()" style="background:#ef4444;">Effacer</button>
                    <button class="btn-draw" id="btnPredict" onclick="analyzeAndPredict()" style="background:#10b981; flex:1;">Analyser & Pr√©dire</button>
                </div>
                <div class="dataset-info" id="currentInputInfo">En attente de dessin...</div>
            </div>
        </div>

        <div class="controls" id="controlsContainer">
            <button onclick="startBatchTraining()" id="trainBtn" class="btn-train">üéì Entra√Æner (500 images spatiales)</button>
            <select id="speedControl">
                <option value="1">Vitesse : x1</option>
                <option value="3">Vitesse : x3</option>
                <option value="10">Vitesse : x10</option>
                <option value="0" selected>Instantan√©</option>
            </select>
            <button onclick="resetNetwork()" style="background:#475569; color:white;">üîÑ Reset</button>
        </div>

        <div class="training-status" id="trainingStatus">
            <h3 style="margin:0; color:#c084fc;">Apprentissage des zones (Haut/Bas)...</h3>
            <div class="epoch-bar-container"><div class="epoch-bar-fill" id="epochBar"></div></div>
            <div style="display:flex; justify-content:space-between; color:#a78bfa;">
                <span id="epochText">√âpoque : 0 / 1000</span>
                <span id="errorText">Erreur : Calcul...</span>
            </div>
        </div>
        
        <div id="resultBox" class="result-box"></div>

        <div class="network-container" id="networkContainer">
            <canvas id="synapseCanvas"></canvas>
            
            <div class="network-layers">
                <div class="layer" id="layer-input"><div class="layer-title">Traits Positionn√©s</div></div>
                <div class="layer" id="layer-hidden-1"><div class="layer-title">Cach√©e 1</div></div>
                <div class="layer" id="layer-hidden-2"><div class="layer-title">Cach√©e 2</div></div>
                <div class="layer" id="layer-output"><div class="layer-title">Sortie</div></div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION DU R√âSEAU (10 ENTR√âES) ---
        const features = ['H_T', 'H_M', 'H_B', 'V', 'D', 'L', 'C_T', 'C_B', 'B_T', 'B_B'];
        const featureNames = {
            'H_T': 'Horiz. Haut', 'H_M': 'Horiz. Milieu', 'H_B': 'Horiz. Bas',
            'V': 'Vertical (Glob.)', 'D': 'Diag. / (Glob.)', 'L': 'Oblique \\ (Glob.)',
            'C_T': 'Courbe Haut', 'C_B': 'Courbe Bas',
            'B_T': 'Boucle Haut', 'B_B': 'Boucle Bas'
        };
        
        // SIGNATURES CORRIG√âES (0 vs 4)
        const basePatterns = {
            0: [0.3, 0.0, 0.3, 0.6, 0.0, 0.0, 0.9, 0.9, 1.0, 1.0], 
            1: [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            2: [0.0, 0.0, 0.9, 0.1, 0.8, 0.0, 0.8, 0.0, 0.0, 0.0],
            3: [0.8, 0.8, 0.1, 0.0, 0.0, 0.0, 0.7, 0.7, 0.0, 0.0],
            4: [0.0, 1.0, 0.0, 1.0, 0.0, 0.8, 0.0, 0.0, 0.0, 0.0], // H_M=1, L=0.8, C=0, B=0
            5: [0.9, 0.8, 0.1, 0.5, 0.0, 0.0, 0.0, 0.8, 0.0, 0.1],
            6: [0.0, 0.0, 0.0, 0.3, 0.0, 0.2, 0.8, 0.8, 0.0, 0.9],
            7: [1.0, 0.0, 0.0, 0.2, 0.0, 0.9, 0.0, 0.0, 0.0, 0.0],
            8: [0.0, 0.2, 0.0, 0.2, 0.2, 0.2, 0.7, 0.7, 0.9, 0.9],
            9: [0.0, 0.0, 0.0, 0.5, 0.0, 0.2, 0.8, 0.2, 0.9, 0.0]
        };

        const NUM_INPUTS = 10;
        const NUM_HIDDEN_1 = 10;
        const NUM_HIDDEN_2 = 10; 
        const NUM_OUTPUTS = 10;

        let W1 = [], B1 = [];
        let W2 = [], B2 = [];
        let W3 = [], B3 = [];
        
        let isTraining = false;
        let selectedDigit = "Dessin";
        let currentInputValues = []; 
        let trainingDataset = []; 
        let isModelTrained = false;
        let helpEnabled = true;

        const sigmoid = x => 1 / (1 + Math.exp(-x));
        const dSigmoid = y => y * (1 - y);

        // --- GESTION DE L'AIDE ---
        function toggleHelp() {
            helpEnabled = document.getElementById('helpToggle').checked;
            if(!helpEnabled) hideAllBubbles();
            else showBubbleStep(getCurrentStep());
        }

        function hideAllBubbles() {
            for(let i=1; i<=4; i++) {
                const b = document.getElementById(`help-bubble-${i}`);
                if(b) b.classList.remove('visible');
            }
        }

        function showBubbleStep(step) {
            if(!helpEnabled) return;
            hideAllBubbles();
            
            const bubble = document.getElementById(`help-bubble-${step}`);
            if(!bubble) return;

            let targetEl;
            if(step === 1) targetEl = document.getElementById('trainBtn');
            if(step === 2) targetEl = document.getElementById('drawingCanvas');
            if(step === 3) targetEl = document.getElementById('btnPredict'); 
            if(step === 4) targetEl = document.getElementById('resultBox');

            if(targetEl) {
                const rect = targetEl.getBoundingClientRect();
                const contRect = document.querySelector('.container').getBoundingClientRect();
                
                const top = rect.top - contRect.top;
                const left = rect.left - contRect.left + (rect.width / 2);
                
                if(step === 1) { 
                    bubble.style.top = (top - 80) + 'px'; 
                    bubble.style.left = left + 'px';
                    bubble.style.transform = 'translateX(-50%)';
                    bubble.className = 'help-bubble arrow-bottom visible';
                }
                else if(step === 2) { 
                    bubble.style.top = (top - 80) + 'px';
                    bubble.style.left = left + 'px';
                    bubble.style.transform = 'translateX(-50%)';
                    bubble.className = 'help-bubble arrow-bottom visible';
                }
                else if(step === 3) { 
                    bubble.style.top = (top + 60) + 'px';
                    bubble.style.left = left + 'px';
                    bubble.style.transform = 'translateX(-50%)';
                    bubble.className = 'help-bubble arrow-top visible';
                }
                else if(step === 4) { 
                    bubble.style.top = (top + rect.height + 20) + 'px';
                    bubble.style.left = left + 'px';
                    bubble.style.transform = 'translateX(-50%)';
                    bubble.className = 'help-bubble arrow-top visible';
                }
            }
        }

        function getCurrentStep() {
            if(!isModelTrained) return 1;
            if(document.getElementById('resultBox').style.display === 'block') return 4;
            if(currentStrokes.length > 0) return 3;
            return 2;
        }

        // --- G√âN√âRATION DE DONN√âES (DATASET) ---
        function generateNoisyPattern(digit) {
            const base = basePatterns[digit];
            return base.map(val => {
                let noise = (Math.random() - 0.5) * 0.4; 
                return Math.max(0, Math.min(1, val + noise));
            });
        }

        function generateDataset() {
            trainingDataset = [];
            for(let d=0; d<10; d++) {
                for(let i=0; i<70; i++) {
                    trainingDataset.push({
                        X: generateNoisyPattern(d),
                        targetDigit: d
                    });
                }
            }
            trainingDataset.sort(() => Math.random() - 0.5);
        }

        // --- GESTION DU DESSIN (CANVAS) ---
        const drawCanvas = document.getElementById('drawingCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        let isDrawing = false;
        let currentStrokes = [];
        let currentPath = [];

        drawCtx.lineWidth = 12;
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';
        drawCtx.strokeStyle = '#0f172a';

        function getMousePos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function startDraw(e) {
            e.preventDefault();
            if(isTraining || !isModelTrained) return;
            isDrawing = true;
            currentPath = [];
            const pos = getMousePos(e);
            currentPath.push(pos);
            drawCtx.beginPath();
            drawCtx.moveTo(pos.x, pos.y);
            hideAllBubbles(); 
        }

        function draw(e) {
            if (!isDrawing || isTraining || !isModelTrained) return;
            e.preventDefault();
            const pos = getMousePos(e);
            currentPath.push(pos);
            drawCtx.lineTo(pos.x, pos.y);
            drawCtx.stroke();
        }

        function endDraw(e) {
            if (!isDrawing) return;
            if(e && e.cancelable) e.preventDefault();
            isDrawing = false;
            if (currentPath.length > 1) {
                currentStrokes.push(currentPath);
                showBubbleStep(3);
            }
        }

        drawCanvas.addEventListener('mousedown', startDraw);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', endDraw);
        drawCanvas.addEventListener('mouseout', endDraw);
        drawCanvas.addEventListener('touchstart', startDraw, {passive: false});
        drawCanvas.addEventListener('touchmove', draw, {passive: false});
        drawCanvas.addEventListener('touchend', endDraw);

        function clearDrawing() {
            if(isTraining) return;
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            currentStrokes = [];
            clearActivations();
            document.getElementById('resultBox').style.display = 'none';
            document.getElementById('currentInputInfo').textContent = "En attente de dessin...";
            showBubbleStep(2); 
        }

        function checkIntersection(p1, p2, p3, p4) {
            let det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);
            if (det === 0) return false;
            let lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;
            let gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;
            return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
        }

        async function analyzeAndPredict() {
            if(isTraining) return;
            if (currentStrokes.length === 0) {
                alert("Dessinez d'abord quelque chose !");
                return;
            }
            analyzeDrawing();
            await runForwardPass();
        }

        function analyzeDrawing() {
            let H_T=0, H_M=0, H_B=0;
            let V=0, D=0, L=0;
            let C_T=0, C_B=0;
            let B_T=0, B_B=0;
            
            let totalLen = 0;
            let lines = [];
            let allPoints = [];

            // Analyser chaque trait
            currentStrokes.forEach(stroke => {
                if(stroke.length < 2) return;
                let strokeLen = 0;
                let strokePointsY = 0;
                let strokeDist = 0; 

                let startP = stroke[0];
                let endP = stroke[stroke.length - 1];
                strokeDist = Math.sqrt(Math.pow(endP.x - startP.x, 2) + Math.pow(endP.y - startP.y, 2));

                stroke.forEach(p => { allPoints.push(p); strokePointsY += p.y; });
                
                // --- DETECTEUR DE DROITURE ---
                let isStraight = false;
                for(let i=0; i<stroke.length-1; i++) {
                    let dx = stroke[i+1].x - stroke[i].x;
                    let dy = stroke[i+1].y - stroke[i].y;
                    strokeLen += Math.sqrt(dx*dx + dy*dy);
                }
                
                if(strokeLen > 20 && (strokeDist / strokeLen) > 0.94) {
                    isStraight = true;
                }

                totalLen += strokeLen;
                
                let prevAngleFull = null;

                for(let i=0; i<stroke.length-1; i++) {
                    let dx = stroke[i+1].x - stroke[i].x;
                    let dy = stroke[i+1].y - stroke[i].y;
                    let len = Math.sqrt(dx*dx + dy*dy);
                    if(len === 0) continue;

                    lines.push({p1: stroke[i], p2: stroke[i+1]});
                    let midY = (stroke[i].y + stroke[i+1].y) / 2;

                    // Angle 0-360
                    let angleFull = Math.atan2(dy, dx) * 180 / Math.PI;
                    if (angleFull < 0) angleFull += 360;
                    
                    // Angle 0-180
                    let angle = angleFull;
                    if (angle >= 180) angle -= 180;
                    
                    // Classification avec ZONES
                    if(angle < 25 || angle > 155) { // Horizontal
                        if (midY < 66) H_T += len;
                        else if (midY < 133) H_M += len;
                        else H_B += len;
                    }
                    else if(angle > 65 && angle < 115) V += len; 
                    else if(angle >= 25 && angle <= 65) L += len; 
                    else if(angle >= 115 && angle <= 155) D += len; 

                    // Courbe (Interdit si trait droit)
                    if (!isStraight && prevAngleFull !== null) {
                        let diff = Math.abs(angleFull - prevAngleFull);
                        if (diff > 180) diff = 360 - diff;
                        if (diff > 3 && diff < 50) {
                            if (midY < 100) C_T += len * 1.5;
                            else C_B += len * 1.5;
                        }
                    }
                    prevAngleFull = angleFull;
                }
            });

            // Boucle 
            let minX = Math.min(...allPoints.map(p=>p.x));
            let maxX = Math.max(...allPoints.map(p=>p.x));
            let bbDiag = Math.sqrt(Math.pow(maxX-minX, 2) + Math.pow(Math.max(...allPoints.map(p=>p.y))-Math.min(...allPoints.map(p=>p.y)), 2));

            currentStrokes.forEach(stroke => {
                 let strokeLen = 0; 
                 for(let i=0; i<stroke.length-1; i++) {
                    let dx = stroke[i+1].x - stroke[i].x;
                    let dy = stroke[i+1].y - stroke[i].y;
                    strokeLen += Math.sqrt(dx*dx + dy*dy);
                 }
                 
                 let start = stroke[0];
                 let end = stroke[stroke.length-1];
                 let dist = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
                 let isStraight = (strokeLen > 20 && (dist / strokeLen) > 0.94);

                 if (!isStraight && totalLen > 50 && dist < bbDiag * 0.35) {
                     let avgY = stroke.reduce((sum, p) => sum + p.y, 0) / stroke.length;
                     if(avgY < 100) B_T += 1.0; else B_B += 1.0;
                 }
            });

            // Intersections
            let intersections = 0;
            for(let i=0; i<lines.length; i+=3) { 
                for(let j=i+15; j<lines.length; j+=3) { 
                    if(checkIntersection(lines[i].p1, lines[i].p2, lines[j].p1, lines[j].p2)) {
                        intersections++;
                        let crossY = (lines[i].p1.y + lines[j].p1.y) / 2;
                        if(crossY < 100) B_T += 0.5; else B_B += 0.5;
                    }
                }
            }

            // Normalisation ET Contraste FORT (cubic)
            if(totalLen > 0) {
                const contrast = (val) => { let norm = Math.min(1.0, val); return Math.pow(norm, 3); }; 
                
                H_T = contrast((H_T / totalLen) * 2.5);
                H_M = contrast((H_M / totalLen) * 2.5);
                H_B = contrast((H_B / totalLen) * 2.5);
                
                V = contrast((V / totalLen) * 2.0);
                D = contrast((D / totalLen) * 2.5);
                L = contrast((L / totalLen) * 2.5);
                
                C_T = Math.min(1.0, (C_T / totalLen) * 1.5);
                C_B = Math.min(1.0, (C_B / totalLen) * 1.5);
            }
            B_T = Math.min(1.0, B_T);
            B_B = Math.min(1.0, B_B);

            // Petit hack 0 vs 4
            if(H_M > 0.5 && V > 0.5) {
                B_T *= 0.1; B_B *= 0.1;
                C_T *= 0.1; C_B *= 0.1;
            }

            currentInputValues = [H_T, H_M, H_B, V, D, L, C_T, C_B, B_T, B_B];
            
            // On ne cleare plus visuellement ici pour √©viter le "flash" avant l'animation
            document.getElementById('resultBox').style.display = 'none';
            document.getElementById('currentInputInfo').textContent = "Signature spatiale captur√©e.";
            
            for(let i=0; i<NUM_INPUTS; i++) updateNodeUI(`in-${i}`, currentInputValues[i]);
        }

        // --- INITIALISATION UI & R√âSEAU ---
        function initDOM() {
            // Entr√©e
            const lInput = document.getElementById('layer-input');
            features.forEach((f, i) => {
                lInput.innerHTML += `
                    <div class="node node-input" id="in-${i}">
                        <div class="node-name">${featureNames[f]}</div>
                        <div class="gauge-container"><div class="gauge-fill" id="fill-in-${i}"></div></div>
                        <div class="node-val" id="val-in-${i}">0.00</div>
                    </div>`;
            });

            // Cach√©e 1
            const lHidden1 = document.getElementById('layer-hidden-1');
            for(let i=0; i<NUM_HIDDEN_1; i++) {
                lHidden1.innerHTML += `
                    <div class="node node-hidden-1" id="hid1-${i}">
                        <div class="node-name">Neurone C1.${i+1}</div>
                        <div class="node-specialty" id="spec-hid1-${i}">Mixte</div>
                        <div class="gauge-container"><div class="gauge-fill" id="fill-hid1-${i}"></div></div>
                        <div class="node-val" id="val-hid1-${i}">0.00</div>
                    </div>`;
            }

            // Cach√©e 2
            const lHidden2 = document.getElementById('layer-hidden-2');
            for(let i=0; i<NUM_HIDDEN_2; i++) {
                lHidden2.innerHTML += `
                    <div class="node node-hidden-2" id="hid2-${i}">
                        <div class="node-name">Neurone C2.${i+1}</div>
                        <div class="node-specialty" id="spec-hid2-${i}">Abstrait</div>
                        <div class="gauge-container"><div class="gauge-fill" id="fill-hid2-${i}"></div></div>
                        <div class="node-val" id="val-hid2-${i}">0.00</div>
                    </div>`;
            }

            // Sortie
            const lOutput = document.getElementById('layer-output');
            for(let i=0; i<NUM_OUTPUTS; i++) {
                lOutput.innerHTML += `
                    <div class="node node-output" id="out-${i}">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <strong>${i}</strong>
                            <span class="node-val" id="val-out-${i}" style="margin:0;">0%</span>
                        </div>
                        <div class="gauge-container" style="height:4px; margin-top:2px;"><div class="gauge-fill" id="fill-out-${i}"></div></div>
                    </div>`;
            }
        }

        function resetNetwork() {
            W1 = Array.from({length: NUM_HIDDEN_1}, () => Array.from({length: NUM_INPUTS}, () => Math.random() * 2 - 1));
            B1 = Array.from({length: NUM_HIDDEN_1}, () => Math.random() * 2 - 1);
            W2 = Array.from({length: NUM_HIDDEN_2}, () => Array.from({length: NUM_HIDDEN_1}, () => Math.random() * 2 - 1));
            B2 = Array.from({length: NUM_HIDDEN_2}, () => Math.random() * 2 - 1);
            W3 = Array.from({length: NUM_OUTPUTS}, () => Array.from({length: NUM_HIDDEN_2}, () => Math.random() * 2 - 1));
            B3 = Array.from({length: NUM_OUTPUTS}, () => Math.random() * 2 - 1);
            
            isModelTrained = false;
            document.getElementById('drawingLock').style.display = 'flex';
            document.getElementById('trainBtn').textContent = 'üéì Entra√Æner (500 images spatiales)';
            document.getElementById('trainBtn').classList.remove('success');
            
            generateDataset(); 
            clearActivations();
            drawSynapses();
            updateLabels();
            document.getElementById('resultBox').style.display = 'none';
            
            setTimeout(() => showBubbleStep(1), 500);
        }

        function clearActivations() {
            for(let i=0; i<NUM_INPUTS; i++) updateNodeUI(`in-${i}`, 0);
            for(let i=0; i<NUM_HIDDEN_1; i++) updateNodeUI(`hid1-${i}`, 0);
            for(let i=0; i<NUM_HIDDEN_2; i++) updateNodeUI(`hid2-${i}`, 0);
            for(let i=0; i<NUM_OUTPUTS; i++) {
                updateNodeUI(`out-${i}`, 0);
                document.getElementById(`out-${i}`).classList.remove('winner');
            }
            document.querySelectorAll('.node').forEach(n => n.classList.remove('active'));
        }

        function updateNodeUI(id, val, isPercentage=false) {
            const elFill = document.getElementById(`fill-${id}`);
            if(elFill) {
                elFill.style.width = `${Math.max(0, Math.min(100, val * 100))}%`;
                elFill.style.backgroundColor = `rgba(16, 185, 129, ${0.3 + val*0.7})`;
            }
            const elVal = document.getElementById(`val-${id}`);
            if(elVal) elVal.textContent = isPercentage ? `${Math.round(val*100)}%` : val.toFixed(2);
        }

        function updateLabels() {
            for(let j=0; j<NUM_HIDDEN_1; j++) {
                let maxW = -Infinity, bestInputIdx = -1;
                for(let i=0; i<NUM_INPUTS; i++) {
                    if(W1[j][i] > maxW) { maxW = W1[j][i]; bestInputIdx = i; }
                }
                const el = document.getElementById(`spec-hid1-${j}`);
                if(maxW > 0.5) el.textContent = `Expert: ${featureNames[features[bestInputIdx]]}`;
                else el.textContent = `Mixte`;
            }
        }

        function drawSynapses(activeLayer = -1) {
            const canvas = document.getElementById('synapseCanvas');
            const container = document.getElementById('networkContainer');
            const ctx = canvas.getContext('2d');
            
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const getCenter = (id) => {
                const el = document.getElementById(id);
                if(!el) return {x:0, y:0};
                const rect = el.getBoundingClientRect();
                const contRect = container.getBoundingClientRect();
                return {
                    x: rect.left - contRect.left + rect.width / 2,
                    y: rect.top - contRect.top + rect.height / 2
                };
            };

            const drawConnections = (numA, numB, prefixA, prefixB, weights, isLayerActive) => {
                for (let i = 0; i < numB; i++) {
                    const target = getCenter(`${prefixB}-${i}`);
                    for (let j = 0; j < numA; j++) {
                        const source = getCenter(`${prefixA}-${j}`);
                        const w = weights[i][j];
                        
                        ctx.beginPath();
                        ctx.moveTo(source.x + 70, source.y); 
                        ctx.lineTo(target.x - 70, target.y); 
                        
                        const isPositive = w > 0;
                        const alpha = isLayerActive ? 0.8 : 0.15;
                        ctx.strokeStyle = isPositive ? `rgba(56, 189, 248, ${alpha})` : `rgba(248, 113, 113, ${alpha})`;
                        ctx.lineWidth = Math.min(Math.abs(w) * 3, 6) + 0.5;
                        
                        if (isLayerActive) {
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = ctx.strokeStyle;
                        } else {
                            ctx.shadowBlur = 0;
                        }
                        ctx.stroke();
                    }
                }
            };

            drawConnections(NUM_INPUTS, NUM_HIDDEN_1, 'in', 'hid1', W1, activeLayer === 1);
            drawConnections(NUM_HIDDEN_1, NUM_HIDDEN_2, 'hid1', 'hid2', W2, activeLayer === 2);
            drawConnections(NUM_HIDDEN_2, NUM_OUTPUTS, 'hid2', 'out', W3, activeLayer === 3);
        }

        window.addEventListener('resize', () => { drawSynapses(); showBubbleStep(getCurrentStep()); });
        const sleep = ms => new Promise(r => setTimeout(r, ms));
        
        async function runForwardPass() {
            if(isTraining) return;
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('resultBox').style.display = 'none';
            clearActivations();
            
            const speedFact = parseFloat(document.getElementById('speedControl').value);
            const delay = (ms) => speedFact > 0 ? sleep(ms / speedFact) : Promise.resolve();
            const inputs = currentInputValues;
            
            // 1. INPUT
            for(let i=0; i<NUM_INPUTS; i++) {
                updateNodeUI(`in-${i}`, inputs[i]);
                document.getElementById(`in-${i}`).classList.add('active');
            }
            drawSynapses(1);
            await delay(800);

            // 2. HIDDEN 1
            document.querySelectorAll('.node-input').forEach(n => n.classList.remove('active'));
            let h1Vals = [];
            for(let i=0; i<NUM_HIDDEN_1; i++) {
                let sum = B1[i];
                for(let j=0; j<NUM_INPUTS; j++) sum += W1[i][j] * inputs[j];
                const act = sigmoid(sum);
                h1Vals.push(act);
                updateNodeUI(`hid1-${i}`, act);
                document.getElementById(`hid1-${i}`).classList.add('active');
            }
            drawSynapses(2);
            await delay(800);

            // 3. HIDDEN 2
            document.querySelectorAll('.node-hidden-1').forEach(n => n.classList.remove('active'));
            let h2Vals = [];
            for(let i=0; i<NUM_HIDDEN_2; i++) {
                let sum = B2[i];
                for(let j=0; j<NUM_HIDDEN_1; j++) sum += W2[i][j] * h1Vals[j];
                const act = sigmoid(sum);
                h2Vals.push(act);
                updateNodeUI(`hid2-${i}`, act);
                document.getElementById(`hid2-${i}`).classList.add('active');
            }
            drawSynapses(3);
            await delay(800);

            // 4. OUTPUT
            document.querySelectorAll('.node-hidden-2').forEach(n => n.classList.remove('active'));
            let outVals = [];
            for(let i=0; i<NUM_OUTPUTS; i++) {
                let sum = B3[i];
                for(let j=0; j<NUM_HIDDEN_2; j++) sum += W3[i][j] * h2Vals[j];
                const act = sigmoid(sum);
                outVals.push(act);
                updateNodeUI(`out-${i}`, act, true);
            }
            drawSynapses(-1);

            // R√©sultat
            let bestDigit = -1, maxAct = -1;
            outVals.forEach((val, idx) => { if(val > maxAct) { maxAct = val; bestDigit = idx; } });
            document.getElementById(`out-${bestDigit}`).classList.add('winner');
            
            const resBox = document.getElementById('resultBox');
            resBox.style.display = 'block';
            
            let seenFeatures = [];
            currentInputValues.forEach((val, i) => {
                if(val > 0.4) seenFeatures.push(`${featureNames[features[i]]} (${Math.round(val*100)}%)`);
            });
            let seenText = seenFeatures.length > 0 ? seenFeatures.join(", ") : "Rien de distinct";

            resBox.className = 'result-box';
            resBox.style.background = 'rgba(30, 41, 59, 0.9)';
            resBox.style.border = '2px solid #38bdf8';
            resBox.innerHTML = `
            ü§î Pr√©diction : <strong style="font-size:1.5em; color:#38bdf8;">${bestDigit}</strong> (${(maxAct*100).toFixed(1)}%)
            
            <div class="detected-features">
                <strong>üëÅÔ∏è Analyse spatiale du dessin :</strong><br>
                ${seenText}
            </div>

            <div class="result-actions">
                <div class="validation-area">
                    <p style="margin:0 0 5px 0; color:#34d399; font-size:14px;"><strong>L'IA a raison ?</strong></p>
                    <button onclick="reinforceSuccess(${bestDigit})" style="background:#10b981; padding:10px 15px; width:100%; border-radius:5px;">‚úÖ Oui, c'est bien un ${bestDigit} !</button>
                </div>
                
                <div class="correction-area">
                    <p style="margin:0 0 5px 0; color:#f87171; font-size:14px;"><strong>L'IA s'est tromp√©e ?</strong></p>
                    <div style="display:flex; gap:5px;">
                        <select id="correctionSelect" style="padding:5px; flex:1; background:#1e293b; color:white; border:1px solid #f87171;">
                            ${[0,1,2,3,4,5,6,7,8,9].map(n => `<option value="${n}">C'√©tait un ${n}</option>`).join('')}
                        </select>
                        <button onclick="teachSpecificCase()" style="background:#ef4444; padding:5px 10px; border-radius:5px;">Apprendre</button>
                    </div>
                </div>
            </div>`;

            document.getElementById('trainBtn').disabled = false;
            showBubbleStep(4);
        }

        // NOUVEAU : Renforcer le succ√®s
        function reinforceSuccess(digit) {
            trainingDataset.push({ X: [...currentInputValues], targetDigit: digit });
            startBatchTraining(true);
        }

        function teachSpecificCase() {
            const correctDigit = parseInt(document.getElementById('correctionSelect').value);
            trainingDataset.push({ X: [...currentInputValues], targetDigit: correctDigit });
            startBatchTraining(true);
        }

        async function startBatchTraining(isQuickFix = false) {
            isTraining = true;
            hideAllBubbles();
            document.querySelectorAll('.btn-draw').forEach(b => b.disabled = true);
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('resultBox').style.display = 'none';
            document.getElementById('trainingStatus').style.display = 'block';
            clearActivations();

            const LEARNING_RATE = 0.5;
            const TOTAL_EPOCHS = isQuickFix ? 300 : 1500; 
            const BATCH_EPOCHS = isQuickFix ? 30 : 50; 
            let epoch = 0;

            const trainChunk = async () => {
                let globalError = 0;
                
                for(let step=0; step<BATCH_EPOCHS; step++) {
                    if(epoch >= TOTAL_EPOCHS) break;
                    globalError = 0;
                    
                    let batch = [];
                    for(let k=0; k<50; k++) {
                        batch.push(trainingDataset[Math.floor(Math.random() * trainingDataset.length)]);
                    }
                    if(isQuickFix) {
                        let target = parseInt(document.getElementById('correctionSelect') ? document.getElementById('correctionSelect').value : 0);
                        let lastItem = trainingDataset[trainingDataset.length-1];
                        for(let k=0; k<20; k++) batch.push(lastItem); // Remis √† 20 pour un apprentissage efficace
                    }

                    for (let item of batch) {
                        let X = item.X;
                        let target = Array(10).fill(0);
                        target[item.targetDigit] = 1.0; 

                        // --- FORWARD ---
                        let A1 = [];
                        for(let i=0; i<NUM_HIDDEN_1; i++) {
                            let sum = B1[i];
                            for(let j=0; j<NUM_INPUTS; j++) sum += W1[i][j] * X[j];
                            A1.push(sigmoid(sum));
                        }
                        
                        let A2 = [];
                        for(let i=0; i<NUM_HIDDEN_2; i++) {
                            let sum = B2[i];
                            for(let j=0; j<NUM_HIDDEN_1; j++) sum += W2[i][j] * A1[j];
                            A2.push(sigmoid(sum));
                        }

                        let A3 = [];
                        for(let i=0; i<NUM_OUTPUTS; i++) {
                            let sum = B3[i];
                            for(let j=0; j<NUM_HIDDEN_2; j++) sum += W3[i][j] * A2[j];
                            A3.push(sigmoid(sum));
                        }

                        // --- BACKWARD ---
                        let errors3 = [];
                        for(let i=0; i<NUM_OUTPUTS; i++) {
                            let err = target[i] - A3[i];
                            globalError += err * err;
                            errors3.push(err * dSigmoid(A3[i]));
                        }

                        let errors2 = [];
                        for(let j=0; j<NUM_HIDDEN_2; j++) {
                            let err = 0;
                            for(let i=0; i<NUM_OUTPUTS; i++) err += W3[i][j] * errors3[i];
                            errors2.push(err * dSigmoid(A2[j]));
                        }

                        let errors1 = [];
                        for(let j=0; j<NUM_HIDDEN_1; j++) {
                            let err = 0;
                            for(let i=0; i<NUM_HIDDEN_2; i++) err += W2[i][j] * errors2[i];
                            errors1.push(err * dSigmoid(A1[j]));
                        }

                        for(let i=0; i<NUM_OUTPUTS; i++) {
                            B3[i] += LEARNING_RATE * errors3[i];
                            for(let j=0; j<NUM_HIDDEN_2; j++) W3[i][j] += LEARNING_RATE * errors3[i] * A2[j];
                        }
                        for(let i=0; i<NUM_HIDDEN_2; i++) {
                            B2[i] += LEARNING_RATE * errors2[i];
                            for(let j=0; j<NUM_HIDDEN_1; j++) W2[i][j] += LEARNING_RATE * errors2[i] * A1[j];
                        }
                        for(let i=0; i<NUM_HIDDEN_1; i++) {
                            B1[i] += LEARNING_RATE * errors1[i];
                            for(let j=0; j<NUM_INPUTS; j++) W1[i][j] += LEARNING_RATE * errors1[i] * X[j];
                        }
                    }
                    epoch++;
                }

                const progress = (epoch / TOTAL_EPOCHS) * 100;
                document.getElementById('epochBar').style.width = `${progress}%`;
                document.getElementById('epochText').textContent = `√âpoque : ${epoch} / ${TOTAL_EPOCHS}`;
                document.getElementById('errorText').textContent = `Erreur : ${globalError.toFixed(4)}`;
                
                drawSynapses();
                updateLabels();

                if(epoch < TOTAL_EPOCHS) requestAnimationFrame(trainChunk); 
                else {
                    isTraining = false;
                    document.getElementById('trainingStatus').style.display = 'none';
                    document.querySelectorAll('.btn-draw').forEach(b => b.disabled = false);
                    const resBox = document.getElementById('resultBox');
                    resBox.style.display = 'block';
                    resBox.className = 'result-box success';
                    resBox.style.background = 'rgba(16, 185, 129, 0.2)'; // Green bg
                    resBox.style.border = '2px solid #10b981';
                    
                    if(isQuickFix) {
                        resBox.innerHTML = `üéì <strong>Apprentissage M√©moris√© !</strong><br><span style="font-size:16px;">Le r√©seau a renforc√© ses connexions pour ce cas.</span>`;
                        showBubbleStep(2); // Retour √† l'√©tape dessin
                    } else {
                        isModelTrained = true;
                        document.getElementById('drawingLock').style.display = 'none'; 
                        document.getElementById('trainBtn').textContent = '‚úÖ R√©seau Entra√Æn√©';
                        document.getElementById('trainBtn').classList.add('success');
                        resBox.innerHTML = `üéì <strong>Entra√Ænement Termin√© !</strong><br><span style="font-size:16px;">Erreur finale faible. Le mode <strong>Dessin Libre</strong> est d√©bloqu√© !</span>`;
                        showBubbleStep(2); // √âtape suivante : Dessiner
                    }

                    document.getElementById('trainBtn').disabled = false;
                    drawSynapses(); 
                }
            };
            requestAnimationFrame(trainChunk);
        }

        window.onload = () => { 
            initDOM(); 
            resetNetwork();
        };
    </script>
    <script src="https://chab974.github.io/site-principal/menu/menu.js" defer></script>
</body>
</html>
